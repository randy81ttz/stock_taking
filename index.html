<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>월간회계 커피챗 - 재고실사 최종본 (업데이트)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f3f4f6;
        }
        .app-container {
            width: 100%;
            max-width: 420px;
            height: 85vh;
            max-height: 800px;
            background-color: #A8C5D4;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .main-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            text-align: center;
            color: #4A3728;
            background: linear-gradient(135deg, #FFFDE7, #FFF8E1);
            padding: 2rem;
        }
        .chat-header {
            background-color: #92B3C3;
            color: #3C474D;
            flex-shrink: 0;
        }
        .chat-body {
            scroll-behavior: smooth;
        }
        .chat-bubble {
            max-width: 100%;
            word-wrap: break-word;
        }
        .chat-bubble.me {
            background-color: #FEE500; /* 카카오톡 노란색 */
            color: #3C1E1E;
        }
        .chat-bubble.you {
            background-color: #FFFFFF;
        }
        .timestamp {
            font-size: 0.7rem;
            color: #6b7280;
            flex-shrink: 0;
        }
        .chat-date-separator {
            font-size: 0.75rem;
            color: #ffffff;
            background-color: #83A2B1;
        }
        .message-group {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            max-width: 85%;
        }
        .message-group.me {
            margin-left: auto;
        }
        .message-group.you {
            margin-right: auto;
        }
        .message-group.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .controls {
            flex-shrink: 0;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="app-container rounded-lg shadow-lg border">
        <!-- Main Screen -->
        <div id="main-screen" class="main-screen">
            <div class="flex-grow flex flex-col justify-center items-center">
                <h1 class="text-xl font-bold text-gray-600">월간회계</h1>
                <h2 class="text-2xl font-bold mt-4 text-gray-800">재고실사에 대해 알려 주세요?</h2>
            </div>
            <button id="start-btn" class="w-full bg-yellow-400 hover:bg-yellow-500 text-gray-800 font-bold py-3 px-4 rounded-lg transition duration-300 mt-8 shadow-md">
                시작하기
            </button>
        </div>

        <!-- Chat Container (Initially Hidden) -->
        <div id="chat-container" class="flex flex-col h-full" style="display: none;">
            <!-- Chat Header -->
            <div class="chat-header p-3 flex items-center shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
                <h1 class="text-lg font-bold">권준석 팀장님 (재무회계)</h1>
            </div>

            <!-- Chat Body -->
            <div id="chat-body" class="flex-1 p-4 overflow-y-auto space-y-4 bg-[#A8C5D4]">
                <!-- Date Separator -->
                <div class="text-center my-2">
                    <span id="chat-date" class="chat-date-separator text-white px-3 py-1 rounded-full"></span>
                </div>
                <!-- Conversation Messages will be injected here by JS -->
            </div>

            <!-- Controls -->
            <div class="controls p-4 bg-white border-t">
                <button id="next-btn" class="w-full bg-yellow-400 hover:bg-yellow-500 text-black font-bold py-3 px-4 rounded-lg transition duration-300">
                    다음 대화 보기
                </button>
            </div>
        </div>
    </div>

<script>
    const mainScreen = document.getElementById('main-screen');
    const startButton = document.getElementById('start-btn');
    const chatContainer = document.getElementById('chat-container');
    const chatBody = document.getElementById('chat-body');
    const nextButton = document.getElementById('next-btn');
    const chatDate = document.getElementById('chat-date');
    
    const today = new Date();
    const year = today.getFullYear();
    const month = today.getMonth() + 1;
    const day = today.getDate();
    const week = ['일', '월', '화', '수', '목', '금', '토'];
    const dayOfWeek = week[today.getDay()];
    chatDate.textContent = `${year}년 ${month}월 ${day}일 ${dayOfWeek}요일`;

    const messages = [
        { from: 'me', name: '김동원 대리', time: '오후 2:00', text: "팀장님, 안녕하세요! 매번 재고실사를 할 때마다 궁금한 부분이 많습니다. 재고실사 관련하여 참고할 수 있는 질의응답 같은 자료를 만들어주실 수 있나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:01', text: "물론이죠, 김 대리님! 아주 좋은 생각이에요. 그럼 재고실사 관련하여 전반적으로 하나씩 정리해봅시다. 가장 근본적인 질문부터 시작할까요? ERP가 있는데 왜 굳이 실사를 할까요?" },
        { from: 'me', name: '김동원 대리', time: '오후 2:02', text: "네! ERP로 매일 체크하는데 왜 또 실물 확인을 해야 하는지 늘 궁금했어요." },
        { from: 'you', name: '권준석 팀장', time: '오후 2:03', text: "ERP는 '기록'일 뿐, '실물' 그 자체가 아니기 때문이에요. ERP는 도난, 파손 같은 물리적 손실이나, 품목코드 입력 오류, 오배송처럼 사람이 개입하는 과정에서 발생하는 오류를 감지할 수 없어요. 재고실사는 우리 ERP와 물류 프로세스가 현실과 일치하는지 검증하는 가장 확실한 방법입니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:04', text: "아하! ERP를 검증하는 절차군요. 그럼 실사를 통해 확인하려는 핵심 기준이 뭔가요? '실재성', '완전성' 같은 말이 어렵더라고요." },
        { from: 'you', name: '권준석 팀장', time: '오후 2:05', text: "그 두 가지가 재고실사의 기둥이에요.<br>👉 <b>실재성(Existence)</b>: 장부에 적힌 게 진짜 창고에 있는가? (장부 → 실물)<br>👉 <b>완전성(Completeness)</b>: 창고에 있는 게 전부 장부에 적혔는가? (실물 → 장부)<br>이걸 확인하기 위해 우리는 원칙적으로 모든 품목을 다 세는 '전수조사'를 하는 거고요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:06', text: "그럼 입회하는 타 부서는 왜 '샘플링' 조사를 하나요? 같이 전수조사를 해서 빨리 끝내면 안 되나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:07', text: "그렇게 하면 일이 더 빨리 끝날 것 같지만, 내부통제의 핵심 원칙인 '책임'과 '검증'의 분리에 어긋나기 때문에 절대 그렇게 해서는 안 돼요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:08', text: "책임과 검증의 분리요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:09', text: "네. 재고 보유 부서는 모든 재고 수량을 정확히 파악하고 보고할 '책임'이 있어요. 그래서 전수조사를 직접 수행하는 거고요. 반면 입회 부서는 재고 부서가 그 책임을 다했는지 독립적인 입장에서 '검증'하고 '감독'하는 역할을 해요. 각자의 역할이 명확히 분리되어야 상호 견제가 되고 통제의 목적을 달성할 수 있답니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:10', text: "명확하게 이해됐습니다! 그럼 실무 현장에서 궁금한 점들이 있어요. 실사 중에 수량 차이가 나면 어떻게 해야 하죠?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:11', text: "당황하지 말고 3단계! <b>①즉시 재검증(Recount) → ②주변 확인(다른 곳에 잘못 놓였는지) → ③정확한 기록.</b> 현장에서 섣불리 원인을 단정하지 말고, '재검증 후에도 차이 발생'이라고 명확히 기록해서 회계그룹과 함께 원인을 분석하는 게 중요해요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:12', text: "실사 당일 ERP 재고리스트 전체를 현장에 가져갈 필요는 없나요? 창고의 로케이션별 리스트만 있어도 될까요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:13', text: "네, 그게 훨씬 효율적입니다. 실사 전날 회사 ERP와 창고 로케이션별 리스트를 비교해서 큰 차이가 없는지 미리 확인하는 게 더 중요해요. 당일에는 동선에 따라 효율적으로 셀 수 있는 로케이션별 리스트만 사용하는 것이 맞습니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:14', text: "그렇군요. 그럼 우리 창고에 없는 대여품이나 타처보관품은 어떻게 확인하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:15', text: "좋은 질문이에요. 그럴 땐 해당 보관처로부터 '타처보관확인서'를 공식적으로 받아야 해요. 우리 재고가 거기에 안전하게 있다는 객관적인 증명서죠." },
        { from: 'me', name: '김동원 대리', time: '오후 2:16', text: "아, 그 확인서! 법인인감만 가능한가요? 거래처에서 어려워하던데, 사용인감이나 직인도 되나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:17', text: "아주 중요한 실무 포인트예요. 증빙 효력 순서는 있지만 유연하게 대응할 수 있어요.<br><b>1순위: 법인인감.</b> 가장 확실하죠.<br><b>2순위: 사용인감.</b> 법인인감이 어렵다면 사용인감이 가장 일반적인 차선책입니다.<br><b>3순위: 직인.</b> 이것도 회사의 공식 도장이므로 가능합니다.<br><b>최후의 수단:</b> 정 안되면 담당 부서장 서명과 명함이라도 꼭 받아야 합니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:18', text: "그럴 일은 없겠지만 실사표 위변조 위험이 있지 않을까요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:19', text: "매우 예리한 지적이에요. 그래서 여러 겹의 통제 장치를 둡니다. ①타 부서가 입회해서 상호 검증하고, ②별도 관리부서가 그 결과를 취합하며, ③회계그룹은 과거 데이터와 비교해 이상 징후가 없는지 검토를 하죠. 이렇게 다중 통제로 위험을 줄이는 겁니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:20', text: "그럼 실사 일정은 왜 월말이 아닌 마지막 주 금요일에 하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:21', text: "결산 데이터를 처리할 시간을 벌고, 주중 출하 업무 영향을 최소화하기 위해서예요. 금요일에 실사하고 재고를 정리하면 다음 주 출하업무를 원활하게 시작할 수 있죠." },
        { from: 'me', name: '김동원 대리', time: '오후 2:22', text: "그럼 실사일과 월말 사이의 재고 변동은 어떻게 관리하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:23', text: "<b>'롤 포워드(Roll-Forward)'</b>라는 절차로 관리해요. [실사일 재고 + 기간 중 입고 - 기간 중 출고 = 월말 재고] 공식으로 정확히 계산하고, 감사인도 이 과정을 검증합니다. 그래서 실사 기간 중 모든 입출고를 중단하는 'Cut-off'가 중요한 거고요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:24', text: "저희는 반기마다 실사를 하는데, 꼭 그렇게 자주 해야 하나요? 기말에만 하면 안 되나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:25', text: "반기 실사는 문제점을 조기에 발견하고 연말 업무 부담을 분산시키는 중요한 내부 관리 절차예요. 주로 내부 관리 목적이 강하죠. 반면 기말 실사는 당기 재무제표를 확정하는 거라, 외부감사인까지 입회해서 더 엄격하게 진행하는 거고요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:26', text: "마지막으로 문서 관련 질문입니다! 실사표에 추가하면 좋을 항목이 있을까요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:27', text: "네, 기본 항목에 더해서 <b>'재고 상태'</b> 를 꼭 확인해 주세요. '불량, 파손' 등을 기록하면, 수량뿐만 아니라 재고의 질적인 가치까지 파악해서 더 정확한 자산 평가가 가능해져요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:28', text: "팀장님, 정말 감사합니다! 이제 재고실사의 전체적인 그림과 디테일이 모두 명확해졌어요. 재고실사에 큰 도움이 될 거예요!" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:29', text: "훌륭해요, 김 대리님! 마지막으로 성공적인 실사를 위한 핵심 4가지 원칙만 기억하세요.<br><br><b>1. 사전 교육은 철저히!</b><br><b>2. Cut-off(입출고 통제)는 엄격하게!</b><br><b>3. 2인 1조로 서로 확인!</b><br><b>4. 실사표는 철저히 관리해서 분실 방지!</b><br><br>이것만 잘 지키면 문제없을 거예요. 화이팅!" }
    ];

    let currentMessageIndex = 0;

    function showNextMessage() {
        if (currentMessageIndex >= messages.length) {
            return;
        }

        const msg = messages[currentMessageIndex];
        const messageGroup = document.createElement('div');

        if (msg.from === 'me') {
            messageGroup.className = 'message-group me';
            messageGroup.innerHTML = `
                <div class="flex flex-col items-end">
                    <p class="text-xs font-medium text-gray-800 mr-1 mb-1">${msg.name}</p>
                    <div class="flex items-end justify-end">
                        <span class="timestamp mr-2">${msg.time}</span>
                        <div class="chat-bubble me p-3 rounded-lg">
                            <p class="text-sm">${msg.text}</p>
                        </div>
                    </div>
                </div>
            `;
        } else {
            messageGroup.className = 'message-group you';
            messageGroup.innerHTML = `
                <div class="flex flex-col items-start">
                    <p class="text-xs font-medium text-gray-800 ml-1 mb-1">${msg.name}</p>
                    <div class="flex items-end">
                        <div class="chat-bubble you p-3 rounded-lg shadow">
                            <p class="text-sm">${msg.text}</p>
                        </div>
                        <span class="timestamp ml-2">${msg.time}</span>
                    </div>
                </div>
            `;
        }

        chatBody.appendChild(messageGroup);

        setTimeout(() => {
            messageGroup.classList.add('visible');
            chatBody.scrollTop = chatBody.scrollHeight;
        }, 10);

        currentMessageIndex++;

        if (currentMessageIndex >= messages.length) {
            nextButton.textContent = '모든 대화 보기 완료';
            nextButton.disabled = true;
            nextButton.classList.remove('hover:bg-yellow-500');
            nextButton.classList.add('bg-gray-400', 'cursor-not-allowed');
        }
    }

    startButton.addEventListener('click', () => {
        mainScreen.style.display = 'none';
        chatContainer.style.display = 'flex';
        showNextMessage();
    });

    nextButton.addEventListener('click', showNextMessage);
</script>
</body>
</html>
