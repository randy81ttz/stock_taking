<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>월간회계 커피챗 - 재고실사 최종본 (업데이트)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f3f4f6;
        }
        .app-container {
            width: 100%;
            max-width: 420px;
            height: 85vh;
            max-height: 800px;
            background-color: #A8C5D4;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .main-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            text-align: center;
            color: #4A3728;
            background: linear-gradient(135deg, #FFFDE7, #FFF8E1);
            padding: 2rem;
        }
        .chat-header {
            background-color: #92B3C3;
            color: #3C474D;
            flex-shrink: 0;
        }
        .chat-body {
            scroll-behavior: smooth;
        }
        .chat-bubble {
            max-width: 100%;
            word-wrap: break-word;
        }
        .chat-bubble.me {
            background-color: #FEE500; /* 카카오톡 노란색 */
            color: #3C1E1E;
        }
        .chat-bubble.you {
            background-color: #FFFFFF;
        }
        .timestamp {
            font-size: 0.7rem;
            color: #6b7280;
            flex-shrink: 0;
        }
        .chat-date-separator {
            font-size: 0.75rem;
            color: #ffffff;
            background-color: #83A2B1;
        }
        .message-group {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            max-width: 85%;
        }
        .message-group.me {
            margin-left: auto;
        }
        .message-group.you {
            margin-right: auto;
        }
        .message-group.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .controls {
            flex-shrink: 0;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="app-container rounded-lg shadow-lg border">
        <!-- Main Screen -->
        <div id="main-screen" class="main-screen">
            <div class="flex-grow flex flex-col justify-center items-center">
                <h1 class="text-xl font-bold text-gray-600">월간회계</h1>
                <h2 class="text-2xl font-bold mt-4 text-gray-800">재고실사에 대해 알려 주세요?</h2>
            </div>
            <button id="start-btn" class="w-full bg-yellow-400 hover:bg-yellow-500 text-gray-800 font-bold py-3 px-4 rounded-lg transition duration-300 mt-8 shadow-md">
                시작하기
            </button>
        </div>

        <!-- Chat Container (Initially Hidden) -->
        <div id="chat-container" class="flex flex-col h-full" style="display: none;">
            <!-- Chat Header -->
            <div class="chat-header p-3 flex items-center shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
                <h1 class="text-lg font-bold">권준석 팀장님 (재무회계)</h1>
            </div>

            <!-- Chat Body -->
            <div id="chat-body" class="flex-1 p-4 overflow-y-auto space-y-4 bg-[#A8C5D4]">
                <!-- Date Separator -->
                <div class="text-center my-2">
                    <span id="chat-date" class="chat-date-separator text-white px-3 py-1 rounded-full"></span>
                </div>
                <!-- Conversation Messages will be injected here by JS -->
            </div>

            <!-- Controls -->
            <div class="controls p-4 bg-white border-t">
                <button id="next-btn" class="w-full bg-yellow-400 hover:bg-yellow-500 text-black font-bold py-3 px-4 rounded-lg transition duration-300">
                    다음 대화 보기
                </button>
            </div>
        </div>
    </div>

<script>
    const mainScreen = document.getElementById('main-screen');
    const startButton = document.getElementById('start-btn');
    const chatContainer = document.getElementById('chat-container');
    const chatBody = document.getElementById('chat-body');
    const nextButton = document.getElementById('next-btn');
    const chatDate = document.getElementById('chat-date');
   
    const today = new Date();
    const year = today.getFullYear();
    const month = today.getMonth() + 1;
    const day = today.getDate();
    const week = ['일', '월', '화', '수', '목', '금', '토'];
    const dayOfWeek = week[today.getDay()];
    chatDate.textContent = `${year}년 ${month}월 ${day}일 ${dayOfWeek}요일`;

    const messages = [
        { from: 'me', name: '김동원 대리', time: '오후 2:00', text: "팀장님, 안녕하세요! 매번 재고실사를 할 때마다 궁금한 부분이 많습니다. 재고실사 관련하여 참고할 수 있는 질의응답 같은 자료를 만들어주실 수 있나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:01', text: "물론이죠, 김 대리님! 아주 좋은 생각이에요. 그럼 재고실사 관련하여 전반적으로 하나씩 정리해봅시다. 가장 근본적인 질문부터 시작할까요? ERP가 있는데 왜 굳이 실사를 할까요?" },
        { from: 'me', name: '김동원 대리', time: '오후 2:02', text: "네! ERP로 매일 체크하는데 왜 또 실물 확인을 해야 하는지 늘 궁금했어요." },
        { from: 'you', name: '권준석 팀장', time: '오후 2:03', text: "ERP는 '기록'일 뿐, '실물' 그 자체가 아니기 때문이에요. ERP는 도난, 파손 같은 물리적 손실이나, 품목코드 입력 오류, 오배송처럼 사람이 개입하는 과정에서 발생하는 오류를 감지할 수 없어요. 재고실사는 우리 ERP와 물류 프로세스가 현실과 일치하는지 검증하는 가장 확실한 방법입니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:04', text: "아하! ERP를 검증하는 절차군요. 그럼 실사를 통해 확인하려는 핵심 기준이 뭔가요? '실재성', '완전성' 같은 말이 어렵더라고요." },
        { from: 'you', name: '권준석 팀장', time: '오후 2:05', text: "그 두 가지가 재고실사의 기둥이에요.<br>👉 <b>실재성(Existence)</b>: 장부에 적힌 게 진짜 창고에 있는가? (장부 → 실물)<br>👉 <b>완전성(Completeness)</b>: 창고에 있는 게 전부 장부에 적혔는가? (실물 → 장부)<br>이걸 확인하기 위해 우리는 원칙적으로 모든 품목을 다 세는 '전수조사'를 하는 거고요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:06', text: "그럼 입회하는 타 부서는 왜 '샘플링' 조사를 하나요? 같이 전수조사를 해서 빨리 끝내면 안 되나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:07', text: "그렇게 하면 일이 더 빨리 끝날 것 같지만, 내부통제의 핵심 원칙인 '책임'과 '검증'의 분리에 어긋나기 때문에 절대 그렇게 해서는 안 돼요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:08', text: "책임과 검증의 분리요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:09', text: "네. 재고 보유 부서는 모든 재고 수량을 정확히 파악하고 보고할 '책임'이 있어요. 그래서 전수조사를 직접 수행하는 거고요. 반면 입회 부서는 재고 부서가 그 책임을 다했는지 독립적인 입장에서 '검증'하고 '감독'하는 역할을 해요. 각자의 역할이 명확히 분리되어야 상호 견제가 되고 통제의 목적을 달성할 수 있답니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:10', text: "한 번도 개봉 안 한 밀봉 박스도 모두 뜯어서 확인해야 하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:11', text: "원칙적으로는 확인이 필요하나, 실무적으로는 샘플링 방식을 적용하는 것이 일반적입니다. 여러 박스 중 일부를 무작위로 선정하여 개봉한 후, 내용물의 품목, 수량, 상태가 명시된 것과 일치하는지 확인합니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:12', text: "명확하게 이해됐습니다! 그럼 실무 현장에서 궁금한 점들이 있어요. 실사 중에 수량 차이가 나면 어떻게 해야 하죠?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:13', text: "당황하지 말고 3단계! <b>①즉시 재검증 → ②주변 확인(다른 곳에 잘못 놓였는지) → ③정확한 기록.</b> 현장에서 섣불리 원인을 단정하지 말고, '재검증 후에도 차이 발생'이라고 명확히 기록해서 회계그룹과 함께 원인을 분석하는 게 중요해요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:14', text: "실사 당일 ERP 재고리스트 전체를 현장에 가져갈 필요는 없나요? 창고의 로케이션별 리스트만 있어도 될까요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:15', text: "네, 그게 훨씬 효율적입니다. 실사 전날 회사 ERP와 창고 로케이션별 리스트를 비교해서 큰 차이가 없는지 미리 확인하는 게 더 중요해요. 당일에는 동선에 따라 효율적으로 셀 수 있는 로케이션별 리스트만 사용하는 것이 맞습니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:16', text: "아, 그렇군요. 실사 전날 재고리스트를 비교하고, 당일에는 외부창고의 장소별 리스트로 실사하는 방식이 일반적인가요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:17', text: "네, 매우 체계적이고 일반적인 방식입니다. 사전에 오류를 줄이고, 당일에는 동선에 따라 효율적으로 실사하는 매우 바람직한 실무 절차입니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:18', text: "그럼 우리 창고에 없는 대여품이나 타처보관품은 어떻게 확인하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:19', text: "좋은 질문이에요. 그럴 땐 해당 보관처로부터 '타처보관확인서'를 공식적으로 받아야 해요. 우리 재고가 거기에 안전하게 있다는 객관적인 증명서죠." },
        { from: 'me', name: '김동원 대리', time: '오후 2:20', text: "아, 그 확인서! 그런데 날인 기준을 명확히 알고 싶어요. 법인인감, 사용인감, 직인 중에 어떤 걸 받아야 하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:21', text: "아주 좋은 질문이에요, 김 대리님. 확인서의 중요한 목적은 재고의 실재성뿐만 아니라 <b>우리의 소유권</b>을 입증하는 데 있어요. 그래서 어떤 날인을 받느냐가 매우 중요하죠." },
        { from: 'you', name: '권준석 팀장', time: '오후 2:22', text: "결론부터 말씀드리면 <b>'사용인감' 날인을 요청하는 것을 원칙</b>으로 합니다. 법인인감은 효력은 가장 강력하지만, 상대방에게 너무 큰 법적 부담을 줘서 마찰이 생기기 쉽거든요. 사용인감이 감사 증거로도 충분하고 가장 합리적인 대안입니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:23', text: "이제부터는 사용인감을 원칙으로 요청해야겠네요! 만약 거래처에서 사용인감도 어렵다고 하면 어떻게 하죠?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:24', text: "좋은 질문이에요. 그럴 땐 차선책이 있습니다. <b>재고 관리 책임 부서장의 서명(또는 직책 도장)과 함께 '직인'을 날인하는 방식까지 허용</b>됩니다. 하지만 담당자 개인 서명만 있는 확인서는 회사의 공식 입장으로 보기 어려워 인정되지 않으니, 최소한 직인까지는 꼭 받아내야 합니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:27', text: "알겠습니다! 원칙은 사용인감, 예외적으로 부서장 서명+직인. 그리고 개인 서명은 안 된다! 명확하네요." },
        { from: 'you', name: '권준석 팀장', time: '오후 2:28', text: "네. 그리고 거래처에 요청할 땐 '법적 책임을 묻는 계약서가 아니라, 내부감사 규정상 필수적인 확인 절차입니다.'라고 부드럽게 설명하면 더 수월할 거예요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:25', text: "외부창고 담당자 사인을 왜 꼭 받아야 하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:26', text: "실사 결과에 대한 객관적인 증빙을 확보하고, 향후 발생할 수 있는 분쟁을 예방하기 위함입니다. 실사 결과에 대해 양측이 이의가 없음을 확인하는 중요한 절차입니다." },  
        { from: 'me', name: '김동원 대리', time: '오후 2:29', text: "그럴 일은 없겠지만 실사표 위변조 위험이 있지 않을까요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:30', text: "매우 예리한 지적이에요. 그래서 여러 겹의 통제 장치를 둡니다. ①타 부서가 입회해서 상호 검증하고, ②별도 관리부서가 그 결과를 취합하며, ③회계그룹은 과거 데이터와 비교해 이상 징후가 없는지 검토를 하죠. 이렇게 다중 통제로 위험을 줄이는 겁니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:31', text: "그럼 실사 일정은 왜 월말이 아닌 마지막 주 금요일에 하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:32', text: "결산 데이터를 처리할 시간을 벌고, 주중 출하 업무 영향을 최소화하기 위해서예요. 금요일에 실사하고 재고를 정리하면 다음 주 출하업무를 원활하게 시작할 수 있죠." },
        { from: 'me', name: '김동원 대리', time: '오후 2:33', text: "그럼 실사일과 월말 사이의 재고 변동은 어떻게 관리하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:34', text: "<b>'롤 포워드(Roll-Forward)'</b>라는 절차로 관리해요. [실사일 재고 + 기간 중 입고 - 기간 중 출고 = 월말 재고] 공식으로 정확히 계산하고, 감사인도 이 과정을 검증합니다. 그래서 실사 기간 중 모든 입출고를 중단하는 'Cut-off'가 중요한 거고요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:35', text: "재고실사 때문에 하루 전부터 출하를 마감하는데, 이것도 일반적인 'Cut-off' 절차인가요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:36', text: "네, 매우 일반적이고 필수적인 'Cut-off(기간마감)' 절차입니다. 특정 시점의 재고 수량을 정확히 확정하기 위해, 그 시점 전후의 모든 물류 이동을 물리적으로 중단시키는 것입니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:37', text: "그런데 실사 기준일까지 수입부대비용의 정산이 안 된 상품의 입고 처리를 왜 실사 이후에 하면 안 되나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:38', text: "회계감사 관점에서 상당한 위험이 따르는 방식입니다. 실사일 전에 창고에 도착했다면(실물 O) 반드시 실사에 포함시켜야 합니다. 수입부대비용 처리가 늦어져 전산 입고를 하지 않았다면(장부 X), 실사표 비고란에 '전산 미반영 입고분'으로 명확히 기재하고, 추후 전산 처리 시 실제 도착일자로 소급하여 입력해야 합니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:39', text: "저희는 반기마다 실사를 하는데, 꼭 그렇게 자주 해야 하나요? 기말에만 하면 안 되나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:40', text: "반기 실사는 문제점을 조기에 발견하고 연도말 업무 부담을 분산시키는 중요한 내부 관리 절차예요. 주로 내부 관리 목적이 강하죠. 반면 기말 실사는 당기 재무제표를 확정하는 거라, 외부감사인까지 입회해서 더 엄격하게 진행하는 거고요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:41', text: "마지막으로 문서 관련 질문입니다! 실사표에 추가하면 좋을 항목이 있을까요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:42', text: "네, 기본 항목에 더해서 <b>'재고 상태'</b> 를 꼭 확인해 주세요. '불량, 파손' 등을 기록하면, 수량뿐만 아니라 재고의 질적인 가치까지 파악해서 더 정확한 자산 평가가 가능해져요." },
        { from: 'me', name: '김동원 대리', time: '오후 2:43', text: "아, 그렇군요! 그럼 실사표에 첨부하는 재고리스트는 어떤 것을 첨부해야 하나요?" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:44', text: "감사 증빙의 관점에서 ①실사 당일 사용된 장소별 리스트, ②최종 ERP 재고리스트, ③타처보관확인서 및 대여인수증 등까지 관련된 모든 리스트를 체계적으로 편철하여 보관하는 것이 가장 바람직합니다." },
        { from: 'me', name: '김동원 대리', time: '오후 2:45', text: "팀장님, 정말 감사합니다! 이제 재고실사의 전체적인 그림과 디테일이 모두 명확해졌어요. 재고실사에 큰 도움이 될 거예요!" },
        { from: 'you', name: '권준석 팀장', time: '오후 2:46', text: "훌륭해요, 김 대리님! 마지막으로 성공적인 실사를 위한 핵심 4가지 원칙만 기억하세요.<br><br><b>1. 사전 교육은 철저히!</b><br><b>2. Cut-off(입출고 통제)는 엄격하게!</b><br><b>3. 2인 1조로 서로 확인!</b><br><b>4. 실사표는 철저히 관리해서 분실 방지!</b><br><br>이것만 잘 지키면 문제없을 거예요. 화이팅!" }
    ];

    let currentMessageIndex = 0;

    function showNextMessage() {
        if (currentMessageIndex >= messages.length) {
            return;
        }

        const msg = messages[currentMessageIndex];
        const messageGroup = document.createElement('div');

        if (msg.from === 'me') {
            messageGroup.className = 'message-group me';
            messageGroup.innerHTML = `
                <div class="flex flex-col items-end">
                    <p class="text-xs font-medium text-gray-800 mr-1 mb-1">${msg.name}</p>
                    <div class="flex items-end justify-end">
                        <span class="timestamp mr-2">${msg.time}</span>
                        <div class="chat-bubble me p-3 rounded-lg">
                            <p class="text-sm">${msg.text}</p>
                        </div>
                    </div>
                </div>
            `;
        } else {
            messageGroup.className = 'message-group you';
            messageGroup.innerHTML = `
                <div class="flex flex-col items-start">
                    <p class="text-xs font-medium text-gray-800 ml-1 mb-1">${msg.name}</p>
                    <div class="flex items-end">
                        <div class="chat-bubble you p-3 rounded-lg shadow">
                            <p class="text-sm">${msg.text}</p>
                        </div>
                        <span class="timestamp ml-2">${msg.time}</span>
                    </div>
                </div>
            `;
        }

        chatBody.appendChild(messageGroup);

        setTimeout(() => {
            messageGroup.classList.add('visible');
            chatBody.scrollTop = chatBody.scrollHeight;
        }, 10);

        currentMessageIndex++;

        if (currentMessageIndex >= messages.length) {
            nextButton.textContent = '모든 대화 보기 완료';
            nextButton.disabled = true;
            nextButton.classList.remove('hover:bg-yellow-500');
            nextButton.classList.add('bg-gray-400', 'cursor-not-allowed');
        }
    }

    startButton.addEventListener('click', () => {
        mainScreen.style.display = 'none';
        chatContainer.style.display = 'flex';
        showNextMessage();
    });

    nextButton.addEventListener('click', showNextMessage);
</script>
</body>
</html>
